---
title: Diffie-Hellman Key Exchange in Erlang
date: 2022-11-26T09:24:00Z
tags: erlang
---

## Key Exchange

### DH Parameters

Create `dhparams.pem`:

```
$ openssl dhparam -out dhparams.pem 2048
Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
...........................+........
```

It's not lying; it takes more than a minute on my Core i7 box.

The parameters are **public**. We can load them into Erlang as follows:

```erlang
{ok, DHPem} = file:read_file("dhparams.pem").
[DH] = public_key:pem_decode(DHPem).
{'DHParameter', P, G, _} = public_key:pem_entry_decode(DH).
Params = [P, G].
```

Alice and Bob share the parameters. They can do this in public&dagger;.

&dagger; in the sense that the parameters don't need to be kept secret. The fact that Alice and Bob are sharing keys
might still be of interest to their country's secret police, and perhaps that should be kept private.

### Generate Alice's keypair

```erlang
{PubA, PrivA} = crypto:generate_key(dh, Params).
```

### Generate Bob's keypair

```erlang
{PubB, PrivB} = crypto:generate_key(dh, Params).
```

### Exchange public keys

Alice sends `PubA` to Bob; Bob sends `PubB` to Alice. Details left as an exercise.

### Alice computes shared secret

Alice uses Bob's public key and her private key:

```erlang
Secret = crypto:compute_key(dh, PubB, PrivA, Params).
```

### Bob computes shared secret

Bob uses Alice's public key and his private key:

```erlang
Secret = crypto:compute_key(dh, PubA, PrivB, Params).
```

Alice and Bob have the same shared secret, which they can use to generate a symmetric session key to encrypt and decrypt
messages back and forth between them.

### Key derivation

We then take the shared secret and pass it through a "Key Derivation Function" (KDF) to generate the key to be used for AES encryption.

As Wikipedia says:

> KDFs can be used to [...] obtain keys of a required format, such as converting [...] the result of a Diffieâ€“Hellman
> key exchange into a symmetric key for use with AES.

This is precisely what we need. Everything I've found on Stack Overflow et. al. says to use [HKDF (RFC
5869)](https://www.rfc-editor.org/rfc/rfc5869). And there's an implementation of that in Erlang, for use with TLS.

TODO: It takes a bunch of arguments; how to figure out which ones to use?

## Encryption

```erlang
Message = <<"We attack at dawn">>.
IV = crypto:strong_rand_bytes(16).
CipherText = crypto:crypto_one_time(aes_256_cbc, Key, IV, Message, [{encrypt, true}]).
```

Note: `IV` is public.

...fails because the key is 2048-bit, and AES only supports 128-, 192- and 256-bit keys. Presumably we should have generated shorter DH params...?

## References

- <https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>
- <https://elliotsp.blogspot.com/2014/11/diffie-hellman-key-exchange-in-erlang.html>, but note that
  `crypto:dh_generate_parameters/2` was removed in Crypto 4.3 (Erlang/OTP 21.1).
